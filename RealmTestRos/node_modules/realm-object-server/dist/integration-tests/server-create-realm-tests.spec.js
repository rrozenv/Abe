"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const TestServer_1 = require("../TestServer");
const uuid = require("uuid");
describe('Server ensureRealmExists Tests', function () {
    let server;
    let authService;
    let adminRealm;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        yield server.start();
        authService = server.getService('auth');
        const realmsService = server.getService('realms');
        adminRealm = realmsService['adminRealm'];
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        if (server) {
            yield server.shutdown();
        }
    }));
    const assertPermissions = (realmFile, userId, hasPermissions) => {
        const permissions = adminRealm.objects('Permission').filtered('realmFile = $0 && user.userId = $1', realmFile, userId);
        if (hasPermissions) {
            chai_1.expect(permissions.length).to.equal(1);
            chai_1.expect(permissions[0].mayRead).to.true;
            chai_1.expect(permissions[0].mayWrite).to.true;
            chai_1.expect(permissions[0].mayManage).to.true;
        }
        else {
            chai_1.expect(permissions.length).to.equal(0);
        }
    };
    describe('when creating global Realm', () => {
        it('should be able to create it without owner', () => __awaiter(this, void 0, void 0, function* () {
            const realmPath = `/${uuid.v4()}`;
            const response = yield server.ensureRealmExists(realmPath);
            chai_1.expect(response.path).to.equal(realmPath);
        }));
        it('should fail to create it with owner specified', () => __awaiter(this, void 0, void 0, function* () {
            const realmPath = `/${uuid.v4()}`;
            const user = yield authService.createOrUpdateUser(uuid.v4(), 'nickname', false);
            yield chai_1.assert.isRejected(server.ensureRealmExists(realmPath, user.userId));
        }));
    });
    describe('when creating user Realm', () => {
        it('should be able to create it without owner', () => __awaiter(this, void 0, void 0, function* () {
            const user = yield authService.createOrUpdateUser(uuid.v4(), 'nickname', false);
            const realmPath = `/${user.userId}/foo`;
            const response = yield server.ensureRealmExists(realmPath);
            chai_1.expect(response.path).to.equal(realmPath);
            const realmFile = adminRealm.objectForPrimaryKey('RealmFile', realmPath);
            chai_1.expect(realmFile.owner.userId).to.not.equal(user.userId);
            assertPermissions(realmFile, user.userId, false);
        }));
        it('should be able to create it with owner', () => __awaiter(this, void 0, void 0, function* () {
            const user = yield authService.createOrUpdateUser(uuid.v4(), 'nickname', false);
            const realmPath = `/${user.userId}/foo`;
            const response = yield server.ensureRealmExists(realmPath, user.userId);
            chai_1.expect(response.path).to.equal(realmPath);
            const realmFile = adminRealm.objectForPrimaryKey('RealmFile', realmPath);
            chai_1.expect(realmFile.owner.userId).to.equal(user.userId);
            assertPermissions(realmFile, user.userId, true);
        }));
        it('should be able to create it with ~ path and owner', () => __awaiter(this, void 0, void 0, function* () {
            const user = yield authService.createOrUpdateUser(uuid.v4(), 'nickname', false);
            const realmPath = `/${user.userId}/foo`;
            const response = yield server.ensureRealmExists('/~/foo', user.userId);
            chai_1.expect(response.path).to.equal(realmPath);
            const realmFile = adminRealm.objectForPrimaryKey('RealmFile', realmPath);
            chai_1.expect(realmFile.owner.userId).to.equal(user.userId);
            assertPermissions(realmFile, user.userId, true);
        }));
        it('should fail to create it with ~ path and no owner', () => __awaiter(this, void 0, void 0, function* () {
            const user = yield authService.createOrUpdateUser(uuid.v4(), 'nickname', false);
            yield chai_1.assert.isRejected(server.ensureRealmExists('/~/foo'));
        }));
    });
});
//# sourceMappingURL=server-create-realm-tests.spec.js.map