"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const realms_1 = require("../realms");
const Logger_1 = require("../shared/Logger");
const TestServer_1 = require("../TestServer");
describe('Server starting, shutting down and restarting', function () {
    let server;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        if (server && server.started) {
            yield server.shutdown();
        }
    }));
    const params = {
        logger: new Logger_1.ThrowingLogger(),
    };
    it('should start without logging warnings or errors', () => __awaiter(this, void 0, void 0, function* () {
        yield server.start(params);
    }));
    it('should support opening the admin Realm from the inside', () => __awaiter(this, void 0, void 0, function* () {
        const adminRealm = yield server.openRealm(realms_1.AdminRealm);
        const users = adminRealm.objects('User');
        chai_1.expect(users.length).to.be.at.least(1);
        const firstUser = users[0];
        chai_1.expect(firstUser.userId).to.equal('__admin');
        adminRealm.close();
    }));
    let regularUser;
    it('should support creating a user and opening a Realm from the outside', () => __awaiter(this, void 0, void 0, function* () {
        regularUser = yield Realm.Sync.User.register(server.url, 'regular-user', 'very-secure');
        const url = (server.url + '/~/test-realm').replace('http://', 'realm://');
        const testRealm = yield Realm.open({
            schema: [{
                    name: 'TestClass',
                    properties: {},
                }],
            sync: {
                user: regularUser,
                url,
            }
        });
        const objects = testRealm.objects('TestClass');
        chai_1.expect(objects.length).to.be.equal(0);
        testRealm.close();
    }));
    it('should support opening the admin Realm from the outside', () => __awaiter(this, void 0, void 0, function* () {
        const adminUser = Realm.Sync.User.adminUser(server.adminToken, server.url);
        const url = (server.url + '/__admin').replace('http://', 'realm://');
        const adminRealm = yield Realm.open({
            sync: {
                user: adminUser,
                url,
            }
        });
        const users = adminRealm.objects('User');
        chai_1.expect(users.length).to.be.at.least(1);
        const lastUser = users[users.length - 1];
        chai_1.expect(lastUser.userId).to.equal(regularUser.identity);
        adminRealm.close();
    }));
    it('should shutdown without logging warnings or errors', () => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
    it('should restart without logging warnings or errors', () => __awaiter(this, void 0, void 0, function* () {
        yield server.start(params);
    }));
    it('should shutdown again without logging warnings or errors', () => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
});
//# sourceMappingURL=server-shutdown-start-tests.spec.js.map