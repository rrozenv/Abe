"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AuthProvider_1 = require("../AuthProvider");
const errors = require("../../errors");
const jwt = require("jsonwebtoken");
class JwtAuthProvider extends AuthProvider_1.AuthProvider {
    constructor(config) {
        super();
        this.publicKey = config.publicKey;
        this.userIdFieldName = config.userIdFieldName || 'userId';
        this.isAdminFieldName = config.isAdminFieldName || 'isAdmin';
        this.isAdminValue = config.isAdminValue === undefined || config.isAdminValue;
        this.requiredAttributes = config.requiredAttributes || {};
        this.name = config.providerName || "jwt";
        this.charactersToEscape = config.charactersToEscape || ['|'];
    }
    authenticateOrCreateUser(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = body.data;
            if (accessToken === undefined) {
                throw new errors.realm.MissingParameters('access token');
            }
            try {
                const payload = yield this.verifyAndDecode(accessToken);
                if (!payload || !payload[this.userIdFieldName]) {
                    throw new errors.realm.InvalidCredentials({
                        detail: `The payload is missing or it doesn't contain the field ${this.userIdFieldName}`
                    });
                }
                for (const ra in this.requiredAttributes) {
                    if (payload[ra] !== this.requiredAttributes[ra]) {
                        throw new errors.realm.InvalidCredentials({
                            detail: "The payload does not contain the required attributes",
                        });
                    }
                }
                const isAdmin = payload[this.isAdminFieldName] === this.isAdminValue;
                const userId = this.escapeUserId(payload[this.userIdFieldName]);
                const foundUser = this.service.getUserByProviderId(this.name, userId);
                if (foundUser && foundUser.isAdmin === isAdmin) {
                    return foundUser;
                }
                return yield this.service.createOrUpdateUser(userId, this.name, isAdmin, null, userId);
            }
            catch (err) {
                throw new errors.realm.InvalidCredentials({
                    detail: err.message
                });
            }
        });
    }
    escapeUserId(userId) {
        let escaped = userId;
        if (this.charactersToEscape) {
            for (const character of this.charactersToEscape) {
                escaped = escaped.replace(character, '_');
            }
        }
        return escaped;
    }
    verifyAndDecode(token) {
        return new Promise((resolve, reject) => {
            jwt.verify(token, this.publicKey, {
                algorithms: ["RS256"]
            }, (err, decoded) => {
                if (err) {
                    reject(err.message);
                }
                else {
                    resolve(decoded);
                }
            });
        });
    }
}
exports.JwtAuthProvider = JwtAuthProvider;
//# sourceMappingURL=JwtAuthProvider.js.map