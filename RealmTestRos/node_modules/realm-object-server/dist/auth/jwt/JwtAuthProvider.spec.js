"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const JwtAuthProvider_1 = require("./JwtAuthProvider");
const errors = require("../../errors");
const TestServer_1 = require("../../TestServer");
const expiredAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJmOTVjYzdjZi02MGI3LTQ5YjItYWI0Yi0xZmRjMjgwZWIwYmQiLCJpYXQiOjE1MTEyNzM2NzEsImV4cCI6MTUxMTI3MzY3Nn0.Coify5qazo5XJ46tH_tzhfCvLGM3ucvMA1JLD0fnhay9NFtiUaefM_UwqEwnja82hAMAUt_qNNzH2IdtbAi6dudu2DFdQ-TSWb6kg6Z5Hht-EQ7xpet4qG0BYMd0HJJVNPJJ9PH_bEIYnNpxbXLbvlxaZJ_miN1TrdV2uHd3tjquGBCj1uxP0f2KYUt6C2dUOSzndiNQ4GmTu4-K0JMH0HYMQLr8EiQQMm5J66BaS1ukb-ZnddzI2Y-YZaDJLo0jGr5J0DhIDnXxO_6QLLTu1uEUJvRHoYG3QOyHYIq5iC43glfcu83AggpXKbHsDl007lnb5N2yagbF39IpCRWZ1Q';
const invalidSignatureAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJmOTVjYzdjZi02MGI3LTQ5YjItYWI0Yi0xZmRjMjgwZWIwYmQiLCJpYXQiOjE1MTEyNzM2NzEsImV4cCI6NDY2NzAzMzY3MX0.Vkz_0lcq7ge2WvJ6unBuQcGsYqJlcYvx07pu-FclLJF-8AWA9ENvADy9e1Vu07JfykJ90l13s0iU916WktoeiZPFB46XHWYakmb0FIF38tkd4wX_AALGaGM8hJqHoVZUaUZ3bi2mEM3NDKEdHsBed6sdJk1N7xt2JjYHtSYZSlOcyeaDooINCeK3EnDbyiP2fX6FX80QsevqcrBe-ZPCvjpDeZ382HNv7x5EfyFpgAc7Gg8iVs2toSGg8xPhAsXTh3259cTJuaqxmmCx50q-IsZHX-kGm8Pf5P01d6qt19XsTyUZrHEBzJZuS8pVJkQ0b13BqaPor0XFazb55zQ6RQ';
const invalidAlgorithmAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJmOTVjYzdjZi02MGI3LTQ5YjItYWI0Yi0xZmRjMjgwZWIwYmQiLCJpYXQiOjE1MTEyNzM2NzEsImV4cCI6NDY2NzAzMzY3MX0.UFy_V0G_1ptOzp2jogbGdsGnsDgaidtZnDfa2zyIAyY';
const noUserIdAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE1MTEyODA2OTMsImV4cCI6NDY2NzA0MDY5M30.DrOm7GcOBdk-uAGnd5rvvzejEpVfJl8ukPIleCT5S7F-6ePnSA2M2_QaZBFAWCnf3IV5el04r81kIeif8_ygs2sa05FxaceBeIVongGuKETIySHgFxKsmUaFDMPOPQ6PkEURKurbp2mq5BAyFZMBt5Hi69b-7J3iCFGozjwP-9j_yyVvEfw22VJFmMhjMvkmlQun0VziKSbOfHHddhdJh9Hk4fv6jAin_6opJCFhjFqqmnH5sDeiBnchmurhdSoUnPRdVYhuPDPru-YyHIfg68EbytgXNx-fcY07PZfptGotkMCRMrTyEEKFsw3_wHOaBmR6RI6ThejqfFekXVA5vw';
const validUserAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJmOTVjYzdjZi02MGI3LTQ5YjItYWI0Yi0xZmRjMjgwZWIwYmQiLCJpYXQiOjE1MTEyNzM2NzEsImV4cCI6NDY2NzAzMzY3MX0.AUZiMB-0LyraIWL-CjHGdZR-KdRzqfWPxhyuzsdISgdQdGeXPDd78b_D1mo5c4lBUjJsuTUBJ38Ao5EVnKixe-BbsnasWLNEXErIMD2v3ip4edfqW3oOz1MIdyw-_UEBAlfDqzu3cVtDJlMk1kSbsvxILPxvf0K8mS282qxDR-bSGUhP0rfDZ26A4G3gCOeHes8hZCk5RHIovmIz3u7rmUXogNZ9gC6hwf7YE8HoAZrOIRxQPfPv4UQTpb0i6eOAaA2UL-UDb9PlfrKkw9Z35CmPqDq3DVCWX51mMSNP3edVeDTx2dA7Vv86yRVa1SL5HRcts_l0WHrq4C6qRDTq3Q';
const adminUserAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJmOTVjYzdjZi02MGI3LTQ5YjItYWI0Yi0xZmRjMjgwZWIwYmQiLCJpc0FkbWluIjp0cnVlLCJpYXQiOjE1MTEyNzM2NzEsImV4cCI6NDY2NzAzMzY3MX0.CKTEgPuVIWlrJgY9RzmTqH06qmjmk7RVCCAEBtesvy44Y6sTNtmVqZVMB2x7an6oaQJY88pCffidxdhJlqKp-e2GDfawYl02seiF-McIG3PwtBDujxJwWeaujXdgE3UiVtxrLfajztcb0NzpohyxAF6LaiYlYnysDKzK8tUZST_jLKZo2yQMreqxkfk1JTL4dmER1OfQIyRVLYIFwCabDnfzV6LXjLkwpXkwkdOPkz-hpDaLXayoWOm7M6-cgz3RzsdHxHfHb9wFWyxm8iBgrWRhU0oGV2et5TRzyTyZruSt6XCtRGGYvWWTvyzVzZJk2Q5WHsiMOUQaIB1chgIHUA';
const namespacedUserAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vbXktZG9tYWluLmNvbS91c2VySWQiOiJmOTVjYzdjZi02MGI3LTQ5YjItYWI0Yi0xZmRjMjgwZWIwYmQiLCJpYXQiOjE1MTU0NDk1ODksImV4cCI6MTgzMTAyNTU4OX0.Yg4bQFfNF069XnbzOHcksnLFYamLbGuMFu2bIroWYZcHiZsNa1muyKTZL3yL5hPe-4fVwjBXQUQuX1IM2SYE6V4eOTh4Mgzs-8Rs_GHrTcg1cJEEYym3lV2-bCfhh217qde4GI8C41kOET4oTc0aKWJ86ZJ90VXibzyLqsYvFtQwrfRiy1rfegJpOck75SiylMmKL2l77Nw9F81rm8FI_9WhYHM3o4PcEPWlmNRyP6uKIgNp7eEeh9nL_JXl6XMpML0OinJMqgwTv89gZT6gGPxVd2s7QZlndd5TnR2eOs8wf47Q95ez67ves2f54D3H5GyjMapKpL3ID3StYJ2p1A';
const namespacedAdminAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vbXktZG9tYWluLmNvbS91c2VySWQiOiJmOTVjYzdjZi02MGI3LTQ5YjItYWI0Yi0xZmRjMjgwZWIwYmQiLCJodHRwOi8vbXktZG9tYWluLmNvbS9pc19hZG1pbiI6dHJ1ZSwiaWF0IjoxNTE1NDQ5NjM3LCJleHAiOjE4MzEwMjU2Mzd9.kQ1XZeXXaN12JFGxg-9pEqLMl2oayYVBaQmbSUnwsiT5JKeZPmk1YHMyS6QvxoZzuNvkle6S-VsrL7uCf7R4skFOaYCJV7PLL4GZ7ocFOZl1KJGVp50qOaCifcHeKKOh5IroTGP_nnSgqo4hyi5EW4Mv7ZoWXhOnu88wjrjm3PCLn2nZAwAo3806lVSZjngJ1Mvtq_Z0smfmg2aJVR9S-lp9enlSZeKBn6r_TZkRxoepQIkjBTqs4ttGZm7puGxPBTlLnXHhcAxgDjMjmdeisn3fVCljmHTA4RN6FzGX4kMtr3txBoRDNnt1HTS6TcDdtl50Yz2JevPQMQhQu5DU1w';
const invalidCharactersAccessToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJmb298YmFyIiwiaWF0IjoxNTE2MjgwMDYzLCJleHAiOjE4MzE4NTYwNjN9.Rdj7zXCZx6EdNB-oenJE6F33lK8csWcdHTY3N1AtetLtpMJCilZxEHeEu5L1yBc2oGsPVG_TD53_XhlWlnzcn77e3RO78OM2fpJhFpfNl1_l-VSh13RrpLovsEdfYV3icZ6OApHIk5LyTQlCdh9dKgsGsIHqbIqD4KI04fzX6r6OJhmbChPyb430fd4Jby-WI5CtGo7O_Cl5PG_1FJJug54cMBgHOOGwrorGAd3_hx8j8pPhPV2BMIpRkZAlDzkxXfS3zY0j2-sgX9y62AWhFCWL3pOVTrBXn6Lkpx9CIaxKQnOzmIV7jr2dgb57kouSn8ifOVEehRMu_1Pq7kRMNw';
describe("JwtAuthProvider", () => {
    let provider;
    let server;
    let authService;
    function createServer(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            server = new TestServer_1.TestServer();
            const providerConfig = {
                publicKey: '-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsPJV7FJ5iOgkI6B9o+sE\n/aNHAzfXDNt059CPQathgUvdbpjanfRkNmYhmx7Bfa8ybPFxJZTs53KoLXuAN3uR\nuxFPL6Ki9320JRxlA/zLN7OKklY+M3ftQcvqYuyLvUHwDEG33p5gHngUP7MH+67x\nLWUGSRq2oi6261LwloCceiyzv4UYbxOTvgMC7RYTAcIRfreJTSuww4deffSCtaqd\nbyJLW3G4qUMfEAF5dwxZzx3hSyg9mCyimzdsD5s7TjpQq+mdHudj5mFvN07y11A0\nZqP6KyWQX7JETLJZTJgelqpynqmnNzdGgnxwGkM8h2LlOCXk+z3OpSzXvwfw4AXo\nJwIDAQAB\n-----END PUBLIC KEY-----'
            };
            Object.assign(providerConfig, params);
            provider = new JwtAuthProvider_1.JwtAuthProvider(providerConfig);
            yield server.start({
                authProviders: [provider],
            });
            authService = server.getService('auth');
        });
    }
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        if (server) {
            yield server.shutdown();
        }
    }));
    describe("authenticateOrCreateUser", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        describe("without data param", () => {
            it("should return a MissingParameters exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({}), errors.realm.MissingParameters);
            }));
        });
        describe("with expired access token", () => {
            it("should return an InvalidCredentials exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: expiredAccessToken }), errors.realm.InvalidCredentials);
            }));
        });
        describe("with invalid signature access token", () => {
            it("should return an InvalidCredentials exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: invalidSignatureAccessToken }), errors.realm.InvalidCredentials);
            }));
        });
        describe("with invalid algorithm access token", () => {
            it("should return an InvalidCredentials exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: invalidAlgorithmAccessToken }), errors.realm.InvalidCredentials);
            }));
        });
        describe("with no userId in payload", () => {
            it("should return an InvalidCredentials exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: noUserIdAccessToken }), errors.realm.InvalidCredentials);
            }));
        });
        describe("on first request", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.isDefined(user.userId);
                chai_1.assert.isFalse(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "jwt");
                chai_1.assert.equal(user.accounts[0].providerId, user.userId);
            }));
        });
        describe("on subsequent requests", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserAccessToken }));
                const secondUser = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserAccessToken }));
                chai_1.assert.equal(user.userId, secondUser.userId);
                chai_1.assert.equal(user.accounts[0].providerId, secondUser.accounts[0].providerId);
            }));
        });
        describe("when user is admin", () => {
            it("should set the admin flag", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: adminUserAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.isDefined(user.userId);
                chai_1.assert.isTrue(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "jwt");
                chai_1.assert.equal(user.accounts[0].providerId, user.userId);
            }));
        });
        describe("when user is promoted to admin", () => {
            it("should update isAdmin", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.isDefined(user.userId);
                chai_1.assert.isFalse(user.isAdmin);
                const promotedUser = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: adminUserAccessToken }));
                chai_1.assert.equal(user.userId, promotedUser.userId);
                chai_1.assert.isTrue(promotedUser.isAdmin);
            }));
        });
        describe("when admin user is demoted", () => {
            it("should update isAdmin", () => __awaiter(this, void 0, void 0, function* () {
                const adminUser = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: adminUserAccessToken }));
                chai_1.assert.isTrue(adminUser.created);
                chai_1.assert.isDefined(adminUser.userId);
                chai_1.assert.isTrue(adminUser.isAdmin);
                const demotedUser = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserAccessToken }));
                chai_1.assert.equal(adminUser.userId, demotedUser.userId);
                chai_1.assert.isFalse(demotedUser.isAdmin);
            }));
        });
    });
    describe("authenticateOrCreateUser with overriden fields", () => {
        describe('when userId field is overriden', () => {
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                return createServer({
                    userIdFieldName: 'http://my-domain.com/userId'
                });
            }));
            it('should log in successfully', () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: namespacedUserAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.equal(user.userId, 'f95cc7cf-60b7-49b2-ab4b-1fdc280eb0bd');
                chai_1.assert.isFalse(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "jwt");
                chai_1.assert.equal(user.accounts[0].providerId, user.userId);
            }));
        });
        describe('when isAdmin field is overriden', () => {
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                return createServer({
                    userIdFieldName: 'http://my-domain.com/userId',
                    isAdminFieldName: 'http://my-domain.com/is_admin',
                    isAdminValue: true
                });
            }));
            it('should log in successfully', () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: namespacedAdminAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.equal(user.userId, 'f95cc7cf-60b7-49b2-ab4b-1fdc280eb0bd');
                chai_1.assert.isTrue(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "jwt");
                chai_1.assert.equal(user.accounts[0].providerId, user.userId);
            }));
        });
        describe('when requiredAttributes is provided', () => {
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                return createServer({
                    requiredAttributes: {
                        organization: "realm"
                    }
                });
            }));
            it('should not log in', () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: validUserAccessToken }), errors.realm.InvalidCredentials);
            }));
        });
        describe('when name is overriden', () => {
            beforeEach(() => createServer({
                providerName: 'foo'
            }));
            it('should log in', () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserAccessToken }));
                chai_1.assert.isDefined(user.userId);
                chai_1.assert.equal(user.accounts[0].provider, 'foo');
                chai_1.assert.equal(user.accounts[0].providerId, user.userId);
            }));
        });
        describe('when charactersToEscape provided', () => {
            beforeEach(() => createServer({
                charactersToEscape: ['|']
            }));
            it('should escape the userId', () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: invalidCharactersAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.equal(user.userId, 'foo_bar');
                chai_1.assert.isFalse(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "jwt");
                chai_1.assert.equal(user.accounts[0].providerId, user.userId);
            }));
        });
    });
});
//# sourceMappingURL=JwtAuthProvider.spec.js.map