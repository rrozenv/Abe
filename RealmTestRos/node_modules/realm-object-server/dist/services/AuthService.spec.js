"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const sinon = require("sinon");
const faker = require("faker");
const TestServer_1 = require("../TestServer");
const Token_1 = require("../shared/Token");
const auth_1 = require("../auth");
const errors = require("../errors");
const index_1 = require("../shared/index");
const index_2 = require("../index");
describe('AuthService', () => {
    let server;
    let service;
    let provider;
    let adminAuthToken;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        provider = new auth_1.NicknameAuthProvider();
        yield server.start({
            authProviders: [provider]
        });
        service = server.getService('auth');
        adminAuthToken = Token_1.Token.parse(server.adminToken, server.publicKey);
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
    describe("createOrUpdateUser", () => {
        describe("without a provider ID and provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser(undefined, undefined, false), errors.realm.MissingParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: "providerId",
                        reason: "Missing parameter 'providerId'!",
                    }, {
                        name: "provider",
                        reason: "Missing parameter 'provider'!",
                    }]);
            }));
        });
        describe("without a provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser("some-user", undefined, false), errors.realm.MissingParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: "provider",
                        reason: "Missing parameter 'provider'!",
                    }]);
            }));
        });
        describe("without a providerId", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser(undefined, "nickname", false), errors.realm.MissingParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: "providerId",
                        reason: "Missing parameter 'providerId'!",
                    }]);
            }));
        });
        describe("with a userId that requires URL encoding", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser("some-user", "nickname", false, {}, "some/user"), errors.realm.InvalidParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: 'userId',
                        reason: 'Realm requires the userId that does not require URI encoding.'
                    }]);
            }));
        });
        describe("when the user already exists", () => {
            let user;
            let username;
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, "nickname", false);
            }));
            it("without userId should not create a new user", () => __awaiter(this, void 0, void 0, function* () {
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(username, "nickname", false));
                chai_1.assert.isFalse(result.created);
            }));
            it("with userId should not create a new user", () => __awaiter(this, void 0, void 0, function* () {
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(username, "nickname", false, {}, user.userId));
                chai_1.assert.isFalse(result.created);
            }));
            it("with incorrect userId should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.createOrUpdateUser(username, "nickname", false, {}, "some-other-userid"), errors.realm.InvalidParameters);
            }));
        });
        describe("when the user does not already exist", () => {
            it("without userId should create a new user", () => __awaiter(this, void 0, void 0, function* () {
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(faker.internet.userName(), "nickname", false));
                chai_1.assert.isTrue(result.created);
            }));
            it("with userId should create a new user with the userId", () => __awaiter(this, void 0, void 0, function* () {
                const username = faker.internet.userName();
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(username, "nickname", false, {}, "some-userid"));
                chai_1.assert.equal(result.userId, "some-userid");
                chai_1.assert.isTrue(result.created);
                chai_1.assert.equal(result.accounts[0].provider, "nickname");
                chai_1.assert.equal(result.accounts[0].providerId, username);
            }));
        });
    });
    describe("getUserById", () => {
        describe("when the user does not exist", () => {
            it("should not return a user", () => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield server.authClient.getUserById('some-userId');
                    chai_1.assert.fail();
                }
                catch (e) {
                    const expected = new errors.realm.UnknownAccount();
                    chai_1.expect(e.status).to.equal(expected.status);
                    chai_1.expect(e.code).to.equal(expected.code);
                    chai_1.expect(e.title).to.equal(expected.title);
                }
            }));
        });
        describe("when the user exists", () => {
            let user;
            let username;
            before(() => __awaiter(this, void 0, void 0, function* () {
                username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, 'nickname', false);
            }));
            it("should return the user", () => __awaiter(this, void 0, void 0, function* () {
                const foundUser = yield server.authClient.getUserById(user.userId);
                chai_1.assert.isDefined(foundUser);
                chai_1.assert.equal(foundUser.userId, user.userId);
                chai_1.assert.isFalse(foundUser.isAdmin);
                chai_1.assert.equal(foundUser.accounts[0].provider, "nickname");
                chai_1.assert.equal(foundUser.accounts[0].providerId, username);
            }));
        });
    });
    describe("getUserByProviderId", () => {
        describe("when the user exists", () => {
            let user;
            let username;
            before(() => __awaiter(this, void 0, void 0, function* () {
                username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, 'nickname', false);
            }));
            it('should be able to get a user', () => __awaiter(this, void 0, void 0, function* () {
                const fetchedUser = service.getUserByProviderId("nickname", username);
                chai_1.assert.isDefined(fetchedUser);
                chai_1.assert.isDefined(fetchedUser.userId);
                chai_1.assert.isFalse(fetchedUser.isAdmin);
                chai_1.assert.equal(fetchedUser.accounts[0].provider, "nickname");
                chai_1.assert.equal(fetchedUser.accounts[0].providerId, username);
            }));
        });
        describe("when the user does not exist", () => {
            it('should be able to get a user', () => __awaiter(this, void 0, void 0, function* () {
                const fetchedUser = service.getUserByProviderId("nickname", "some-user");
                chai_1.assert.isUndefined(fetchedUser);
            }));
        });
    });
    describe("updateProviderData", () => {
        describe("with an existing user", () => {
            let user;
            before(() => __awaiter(this, void 0, void 0, function* () {
                const username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, 'nickname', false);
            }));
            it("should call the provider's update function", () => __awaiter(this, void 0, void 0, function* () {
                const spy = sinon.spy(provider, "update");
                const updateData = { debuggy: "mcbuggerson" };
                yield chai_1.assert.isFulfilled(server.authClient.updateProviderData("nickname", user.userId, updateData));
                sinon.assert.calledOnce(spy);
                const args = spy.getCall(0).args;
                chai_1.expect(args[0].userId).to.equal(user.userId);
                chai_1.expect(args[1]).to.deep.equal(updateData);
            }));
        });
        describe("without an existing user", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield server.authClient.updateProviderData("nickname", "some-bogus-userId", {});
                    chai_1.assert.fail();
                }
                catch (e) {
                    const expected = new errors.realm.UnknownAccount();
                    chai_1.expect(e.status).to.equal(expected.status);
                    chai_1.expect(e.code).to.equal(expected.code);
                    chai_1.expect(e.title).to.equal(expected.title);
                }
            }));
        });
        describe("without a valid provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield server.authClient.updateProviderData("snapchat", "lololol", {});
                    chai_1.assert.fail();
                }
                catch (e) {
                    const expected = new errors.realm.InvalidParameters();
                    chai_1.expect(e.status).to.equal(expected.status);
                    chai_1.expect(e.code).to.equal(expected.code);
                    chai_1.expect(e.title).to.equal(expected.title);
                    chai_1.expect(e.invalidParams).to.include.deep.members([{
                            name: "provider",
                            reason: "Invalid parameter 'provider'!"
                        }]);
                }
            }));
        });
    });
    describe("deleteUser", () => {
        describe("without an authToken", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service['deleteUser']("some-bogus-userId", { noAuthToken: "something" }), errors.realm.AccessDenied);
            }));
        });
        describe("without an existing user", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield server.authClient.deleteUser('some-bogus-userId');
                    chai_1.assert.fail();
                }
                catch (e) {
                    const expected = new errors.realm.UnknownUser();
                    chai_1.expect(e.status).to.equal(expected.status);
                    chai_1.expect(e.code).to.equal(expected.code);
                    chai_1.expect(e.title).to.equal(expected.title);
                }
            }));
        });
        describe("Delete a user twice", () => {
            let userId;
            before(() => __awaiter(this, void 0, void 0, function* () {
                const username = faker.internet.userName();
                const user = yield service.createOrUpdateUser(username, 'nickname', false);
                userId = user.userId;
            }));
            it("should accept", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.becomes(service['deleteUser'](userId, { authToken: adminAuthToken }), {});
            }));
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield server.authClient.deleteUser(userId);
                    chai_1.assert.fail();
                }
                catch (e) {
                    const expected = new errors.realm.UnknownUser();
                    chai_1.expect(e.status).to.equal(expected.status);
                    chai_1.expect(e.code).to.equal(expected.code);
                    chai_1.expect(e.title).to.equal(expected.title);
                }
            }));
        });
    });
    describe('revoke', () => {
        it('revokes tokens with no expiration', () => __awaiter(this, void 0, void 0, function* () {
            const token = index_1.generateAdminToken({
                privateKey: server.privateKey
            });
            chai_1.expect(server.tokenValidator.parse(token)).not.to.throw;
            yield server.authClient.revokeToken(token);
            chai_1.expect(() => server.tokenValidator.parse(token)).to.throw(errors.realm.AccessDenied);
        }));
        it('revokes tokens with expiration', () => __awaiter(this, void 0, void 0, function* () {
            const token = index_1.generateAdminToken({
                privateKey: server.privateKey,
                expires: new Date().getTime() / 1000 + 10000
            });
            chai_1.expect(server.tokenValidator.parse(token)).not.to.throw;
            yield server.authClient.revokeToken(token);
            chai_1.expect(() => server.tokenValidator.parse(token)).to.throw(errors.realm.AccessDenied);
        }));
    });
    describe('prune', () => {
        let tokenRevocationRealm;
        before(() => __awaiter(this, void 0, void 0, function* () {
            tokenRevocationRealm = yield server.openRealm(index_2.TokenRevocationRealm);
        }));
        after(() => {
            tokenRevocationRealm.close();
        });
        it('prunes expired tokens', () => __awaiter(this, void 0, void 0, function* () {
            const token = index_1.generateAdminToken({
                privateKey: server.privateKey,
                expires: new Date().getTime() / 1000 + 1
            });
            const tokenData = Token_1.Token.parse(token, server.publicKey).encodedData();
            yield server.authClient.revokeToken(token);
            let revocation = tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', tokenData);
            chai_1.expect(revocation).to.be.ok;
            yield index_1.delay(1100);
            service['pruneRevocationTokens']();
            revocation = tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', tokenData);
            chai_1.expect(revocation).to.be.undefined;
        }));
        it("doesn't prune non-expiring tokens", () => __awaiter(this, void 0, void 0, function* () {
            const noExpirationToken = index_1.generateAdminToken({
                privateKey: server.privateKey
            });
            const futureExpirationToken = index_1.generateAdminToken({
                privateKey: server.privateKey,
                expires: new Date().getTime() / 1000 + 10000
            });
            const noExpirationTokenData = Token_1.Token.parse(noExpirationToken, server.publicKey).encodedData();
            const futureExpirationTokenData = Token_1.Token.parse(futureExpirationToken, server.publicKey).encodedData();
            yield server.authClient.revokeToken(noExpirationToken);
            yield server.authClient.revokeToken(futureExpirationToken);
            let noExpirationRevocation = tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', noExpirationTokenData);
            let futureExpirationRevocation = tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', futureExpirationTokenData);
            chai_1.expect(noExpirationRevocation).to.be.ok;
            chai_1.expect(futureExpirationRevocation).to.be.ok;
            service['pruneRevocationTokens']();
            noExpirationRevocation = tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', noExpirationTokenData);
            futureExpirationRevocation = tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', futureExpirationTokenData);
            chai_1.expect(noExpirationRevocation).to.be.ok;
            chai_1.expect(futureExpirationRevocation).to.be.ok;
        }));
    });
});
//# sourceMappingURL=AuthService.spec.js.map