"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const URI = require("urijs");
const moment = require("moment");
const crypto = require("crypto");
const util_1 = require("../shared/util");
const decorators_1 = require("../decorators");
const Server_1 = require("../Server");
const Token_1 = require("../shared/Token");
const errors = require("../errors");
const realms_1 = require("../realms");
const Token_2 = require("../shared/Token");
const SyncClient_1 = require("../service-clients/SyncClient");
let AuthService = class AuthService {
    constructor(config = {}) {
        this.providers = [];
        this.refreshTokenTtl = config.refreshTokenTtl || moment.duration(10, 'years').asSeconds();
        this.accessTokenTtl = config.accessTokenTtl || moment.duration(6, 'minutes').asSeconds();
    }
    addProvider(provider) {
        this.providers.push(provider);
    }
    getUserByProviderId(provider, providerId) {
        const accounts = this.adminRealm.objects('Account').filtered(`provider = $0 AND providerId = $1`, provider, providerId);
        if (accounts.length > 0) {
            return accounts[0].users[0];
        }
        return undefined;
    }
    createOrUpdateUser(providerId, provider, isAdmin, metadata = {}, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const missingParameters = new Array();
            if (!provider) {
                missingParameters.push('provider');
            }
            if (!providerId) {
                missingParameters.push('providerId');
            }
            if (missingParameters.length > 0) {
                throw new errors.realm.MissingParameters(...missingParameters);
            }
            if (userId) {
                const encodedUserId = encodeURIComponent(userId);
                if (userId !== encodedUserId) {
                    throw new errors.realm.InvalidParameters({
                        name: 'userId',
                        reason: 'Realm requires the userId that does not require URI encoding.'
                    });
                }
            }
            let user = this.getUserByProviderId(provider, providerId);
            if (user && userId && userId !== user.userId) {
                throw new errors.realm.InvalidParameters({
                    name: 'userId',
                    reason: "userId does not match the user found by provider/providerId"
                });
            }
            this.adminRealm.write(() => {
                if (!user) {
                    user = this.adminRealm.create('User', {
                        userId: userId || this.generateUniqueId(),
                        isAdmin: isAdmin || false,
                    });
                    user.accounts.push({
                        provider: provider,
                        providerId: providerId
                    });
                    user.created = true;
                }
                else {
                    user.created = false;
                    if (isAdmin !== undefined) {
                        user.isAdmin = isAdmin;
                    }
                }
                this.adminRealm.delete(user.metadata);
                for (const key in metadata) {
                    user.metadata.push({
                        key: key,
                        value: metadata[key]
                    });
                }
            });
            return user;
        });
    }
    start(server) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger = server.logger.withContext({ service: "auth" });
            this.server = server;
            this.privateKey = server.privateKey;
            this.publicKey = server.publicKey;
            this.adminToken = server.adminToken;
            this.adminRealm = yield server.openRealm(realms_1.AdminRealm);
            this.tokenRevocationRealm = yield server.openRealm(realms_1.TokenRevocationRealm);
            try {
                const userId = "__admin";
                let foundUser = this.adminRealm.objectForPrimaryKey('User', userId);
                if (!foundUser) {
                    foundUser = yield this.createOrUpdateUser(userId, 'realm', true, {}, userId);
                    this.logger.info(`Autocreated admin token user: ${userId}`);
                }
            }
            catch (err) {
                this.logger.error('Failed to autocreate admin token user', err);
            }
            this.pruneRevocationTokens();
            this.cleanupInterval = setInterval(this.pruneRevocationTokens.bind(this), 1000 * 60 * 60 * 24);
            for (const provider of this.providers) {
                this.logger.detail(`Starting auth provider '${provider.name}'`);
                Reflect.set(provider, "service", this);
                if (provider.start) {
                    yield provider.start();
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const provider of this.providers) {
                if (provider.stop) {
                    yield provider.stop();
                }
                Reflect.set(provider, "service", undefined);
            }
            if (this.cleanupInterval) {
                clearInterval(this.cleanupInterval);
            }
            if (this.tokenRevocationRealm) {
                this.tokenRevocationRealm.close();
                delete this.tokenRevocationRealm;
            }
            if (this.adminRealm) {
                this.adminRealm.close();
                delete this.adminRealm;
            }
        });
    }
    authenticate(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const providerName = request.body.provider;
            const appId = request.body["app_id"] || 'io.realm.Auth';
            if (!providerName) {
                throw new errors.realm.MissingParameters('provider');
            }
            if (providerName === 'realm') {
                const data = request.body.data;
                if (!data) {
                    throw new errors.realm.MissingParameters('data');
                }
                let refreshToken;
                try {
                    refreshToken = this.server.tokenValidator.parseRefreshToken(data);
                }
                catch (err) {
                    throw new errors.realm.AccessDenied();
                }
                const path = util_1.validateRealmPath(request.body['path'], refreshToken.identity);
                return yield this.accessToken(path, refreshToken, data, appId);
            }
            const provider = this.providers.find((p) => { return p.name === providerName; });
            if (!provider) {
                throw new errors.realm.InvalidParameters('provider');
            }
            const user = yield provider.authenticateOrCreateUser(request.body);
            const refreshToken = new Token_1.RefreshToken({
                appId,
                identity: user.userId,
                isAdmin: user.isAdmin,
                expires: moment().add(this.refreshTokenTtl, 'second').unix(),
            });
            return {
                refresh_token: {
                    token: refreshToken.sign(this.privateKey),
                    token_data: refreshToken.toJSON(),
                }
            };
        });
    }
    accessToken(path, token, data, app_id) {
        return __awaiter(this, void 0, void 0, function* () {
            path = path.replace('~', token.identity);
            let partialSyncPath;
            const partialIndex = path.indexOf('/__partial/');
            if (partialIndex !== -1) {
                partialSyncPath = path;
                path = path.substring(0, partialIndex);
            }
            let realmFile = this.adminRealm.objectForPrimaryKey('RealmFile', path);
            if (partialSyncPath && !realmFile) {
                yield this.server.realmDirectoryClient.findByPath(path, data);
            }
            const response = yield this.server.realmDirectoryClient.findByPath((partialSyncPath || path), data);
            const syncLabel = response.syncLabel;
            yield util_1.waitForDownload(this.adminRealm);
            realmFile = this.adminRealm.objectForPrimaryKey('RealmFile', path);
            if (!realmFile) {
                throw new Error(`could not find realmfile: ${path}`);
            }
            if (partialSyncPath) {
                const partialRealmFile = this.adminRealm.objectForPrimaryKey('RealmFile', partialSyncPath);
                if (!partialRealmFile) {
                    throw new Error(`could not find realmfile: ${partialSyncPath}`);
                }
            }
            let access = [];
            if (!token.isAdmin) {
                let mayRead = false;
                let mayWrite = false;
                let mayManage = false;
                const permissions = realmFile.permissions.filtered('user.userId = $0 OR user.userId = null', token.identity);
                permissions.forEach(permission => {
                    mayRead = mayRead || permission.mayRead;
                    mayWrite = mayWrite || permission.mayWrite;
                    mayManage = mayManage || permission.mayManage;
                });
                if (mayRead) {
                    access.push('download');
                }
                if (mayWrite) {
                    access.push('upload');
                }
                if (mayManage) {
                    access.push('manage');
                }
                if (access.length === 0) {
                    throw new errors.realm.AccessDenied();
                }
            }
            else {
                access = ['download', 'upload', 'manage'];
            }
            const isAskingForTildePermission = ['__permission', '__perm'].some(name => path === `/${token.identity}/${name}`);
            if (isAskingForTildePermission) {
                yield this.server.permissionsClient.onDemand(data);
            }
            const appId = app_id || "io.realm.Auth";
            const expires = moment().add(this.accessTokenTtl, 'seconds').unix();
            const accessToken = new Token_1.AccessToken({
                identity: token.identity,
                appId,
                access: access,
                path: partialSyncPath || path,
                expires: moment().add(this.accessTokenTtl, 'seconds').unix(),
                syncLabel: syncLabel,
            });
            return {
                access_token: {
                    token: accessToken.sign(this.privateKey),
                    token_data: accessToken.toJSON(),
                }
            };
        });
    }
    revokeToken(tokenData, req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!tokenData || tokenData === "") {
                throw new errors.realm.MissingParameters('token');
            }
            const token = Token_1.Token.parse(tokenData, this.publicKey);
            this.requireAdminOrUserId(req, token.identity);
            const expires = token.expires ? new Date(token.expires * 1000) : null;
            this.tokenRevocationRealm.write(() => {
                this.tokenRevocationRealm.create('TokenRevocation', {
                    expires,
                    token: token.encodedData(),
                    revoked: new Date(),
                }, true);
            });
            return {};
        });
    }
    getUserById(userId, req) {
        this.requireAdminOrUserId(req, userId);
        const user = this.adminRealm.objectForPrimaryKey('User', userId);
        if (!user) {
            throw new errors.realm.UnknownAccount();
        }
        return user;
    }
    getUserByProviderIdApi(provider, providerId, req) {
        const token = req.authToken;
        if (!token) {
            throw new errors.realm.AccessDenied();
        }
        const decodedProviderId = URI.decode(providerId);
        const user = this.getUserByProviderId(provider, decodedProviderId);
        if (user && (Token_2.isAdminToken(token) || user.userId === token.identity)) {
            return user;
        }
        throw new errors.realm.UnknownAccount();
    }
    createOrUpdateUserApi(req, providerId, provider, isAdmin, metadata = {}, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const authToken = req.authToken;
            if (!authToken || !Token_2.isAdminToken(authToken)) {
                throw new errors.realm.AccessDenied();
            }
            return this.createOrUpdateUser(providerId, provider, isAdmin, metadata, userId);
        });
    }
    updateProviderData(providerName, userId, data, req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!req.authToken) {
                throw new errors.realm.AccessDenied();
            }
            if (!userId) {
                userId = req.authToken.identity;
            }
            this.requireAdminOrUserId(req, userId);
            const provider = this.providers.find((p) => { return p.name === providerName; });
            if (!provider) {
                throw new errors.realm.InvalidParameters('provider');
            }
            if (!data) {
                throw new errors.realm.MissingParameters('data');
            }
            const user = this.adminRealm.objectForPrimaryKey('User', userId);
            if (!user) {
                throw new errors.realm.UnknownAccount();
            }
            if (provider.update) {
                return provider.update(user, data);
            }
            return {};
        });
    }
    deleteUser(userId, req) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`User ${userId} is requested to be deleted`);
            this.requireAdminOrUserId(req, userId);
            yield this.deleteUserWithUserId(userId);
            this.logger.debug(`User ${userId} has been deleted`);
            return {};
        });
    }
    pruneRevocationTokens() {
        const deadRevocations = this.tokenRevocationRealm.objects('TokenRevocation').filtered("expires < $0", new Date());
        if (deadRevocations.length > 0) {
            this.tokenRevocationRealm.write(() => {
                this.tokenRevocationRealm.delete(deadRevocations);
            });
        }
    }
    generateUniqueId() {
        return crypto.randomBytes(16).toString('hex');
    }
    requireAdminOrUserId(req, userId) {
        const authToken = req.authToken;
        if (!authToken) {
            throw new errors.realm.AccessDenied();
        }
        const isAdmin = Token_2.isAdminToken(authToken);
        if (!isAdmin) {
            if (!userId) {
                throw new errors.realm.AccessDenied();
            }
            if (userId && userId !== authToken.identity) {
                throw new errors.realm.AccessDenied();
            }
        }
    }
    deleteUserWithUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const adminRealm = this.adminRealm;
            const user = adminRealm.objectForPrimaryKey('User', userId);
            if (!user) {
                throw new errors.realm.UnknownUser();
            }
            const realmFiles = adminRealm.objects('RealmFile')
                .filtered('owner.userId = $0', userId);
            const filesToDelete = realmFiles.map((realmFile) => {
                return {
                    tags: [
                        'role=master',
                        `label=${realmFile.syncLabel}`
                    ],
                    path: realmFile.path
                };
            });
            let providerNames = [];
            adminRealm.write(() => {
                const user = adminRealm.objectForPrimaryKey('User', userId);
                if (!user) {
                    throw new errors.realm.UnknownUser();
                }
                adminRealm.delete(user.metadata);
                providerNames = user.accounts.map((account) => {
                    return account.provider;
                });
                adminRealm.delete(user.accounts);
                const permissions = adminRealm.objects('Permission')
                    .filtered('user.userId = $0', userId);
                adminRealm.delete(permissions);
                const realmFiles = adminRealm.objects('RealmFile')
                    .filtered('owner.userId = $0', userId);
                adminRealm.delete(realmFiles);
                adminRealm.delete(user);
            });
            const deleteUserPromises = [];
            providerNames.forEach((providerName) => {
                const provider = this.providers.find((p) => { return p.name === providerName; });
                if (provider) {
                    deleteUserPromises.push(provider.deleteUser(userId));
                }
            });
            yield Promise.all(deleteUserPromises);
            yield Promise.all(filesToDelete.map((file) => {
                const client = new SyncClient_1.SyncClient(this.server.discovery, this.adminToken, file.tags);
                return client.deleteRealm(file.path).catch((err) => {
                    this.logger.error(`Deletion of a Realm on the sync server failed, path = ${file.path}`);
                });
            }));
            const localUserDir = path.join(this.server.dataPath, "realms", userId);
            fs.remove(localUserDir, (err) => {
                if (err) {
                    this.logger.error(`Unable to remove user directory: '${localUserDir}'`);
                }
            });
        });
    }
};
__decorate([
    decorators_1.Start(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Server_1.Server]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "start", null);
__decorate([
    decorators_1.Stop(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "stop", null);
__decorate([
    decorators_1.Post('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "authenticate", null);
__decorate([
    decorators_1.Post("/revoke"),
    __param(0, decorators_1.Body('token')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "revokeToken", null);
__decorate([
    decorators_1.Get('/users/:user_id'),
    __param(0, decorators_1.Params('user_id')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", realms_1.User)
], AuthService.prototype, "getUserById", null);
__decorate([
    decorators_1.Get('/users/:provider/:provider_id'),
    __param(0, decorators_1.Params('provider')),
    __param(1, decorators_1.Params('provider_id')),
    __param(2, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", realms_1.User)
], AuthService.prototype, "getUserByProviderIdApi", null);
__decorate([
    decorators_1.Put('/users'),
    __param(0, decorators_1.Request()),
    __param(1, decorators_1.Body('provider_id')),
    __param(2, decorators_1.Body('provider')),
    __param(3, decorators_1.Body('is_admin')),
    __param(4, decorators_1.Body('metadata')),
    __param(5, decorators_1.Body('user_id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String, Boolean, Object, String]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "createOrUpdateUserApi", null);
__decorate([
    decorators_1.Put('/:provider'),
    __param(0, decorators_1.Params('provider')),
    __param(1, decorators_1.Body('user_id')),
    __param(2, decorators_1.Body('data')),
    __param(3, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object, Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "updateProviderData", null);
__decorate([
    decorators_1.Delete('/user/:user_id'),
    decorators_1.Delete('/users/:user_id'),
    __param(0, decorators_1.Params('user_id')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "deleteUser", null);
AuthService = __decorate([
    decorators_1.BaseRoute('/auth'),
    decorators_1.ServiceName('auth'),
    __metadata("design:paramtypes", [Object])
], AuthService);
exports.AuthService = AuthService;
//# sourceMappingURL=AuthService.js.map