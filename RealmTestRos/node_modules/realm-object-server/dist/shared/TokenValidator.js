"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Token_1 = require("./Token");
const errors = require("../errors");
const realms_1 = require("../realms");
class TokenValidator {
    constructor({ logger, publicKey, realmFactory, disableRevocation = false, }) {
        this.logger = logger;
        this.publicKey = publicKey;
        this.realmFactory = realmFactory;
        this.disableRevocation = disableRevocation;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.disableRevocation) {
                this.tokenRevocationRealm = yield this.realmFactory.open(realms_1.TokenRevocationRealm);
            }
            this.logger.detail('TokenValidator started');
        });
    }
    stop() {
        if (this.tokenRevocationRealm) {
            this.tokenRevocationRealm.close();
        }
        this.logger.detail('TokenValidator stopped');
    }
    parse(tokenData, mustBeAdmin = false) {
        const token = Token_1.Token.parse(tokenData, this.publicKey);
        if (mustBeAdmin && !Token_1.isAdminToken(token)) {
            throw new errors.realm.InvalidCredentials({
                title: 'Expected an admin'
            });
        }
        if (this.isTokenRevoked(token)) {
            throw new errors.realm.AccessDenied({
                title: 'The token has been revoked'
            });
        }
        return token;
    }
    parseRefreshToken(tokenData, mustBeAdmin = false) {
        const token = this.parse(tokenData, mustBeAdmin);
        if (!(token instanceof Token_1.RefreshToken)) {
            throw new errors.realm.AccessDenied();
        }
        return token;
    }
    isTokenRevoked(token) {
        if (this.disableRevocation) {
            return false;
        }
        if (this.tokenRevocationRealm) {
            const revocation = this.tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', token.encodedData());
            return !!revocation;
        }
        if (!token.canSkipRevocationCheck) {
            this.logger.warn("TokenValidator couldn't check if token was revoked: The TokenRevocationRealm wasn't opened.");
        }
        return false;
    }
}
exports.TokenValidator = TokenValidator;
//# sourceMappingURL=TokenValidator.js.map