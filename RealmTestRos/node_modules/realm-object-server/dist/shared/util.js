"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const virtPath_1 = require("./virtPath");
const errors = require("../errors");
const URI = require("urijs");
function Promisify(callback, ...args) {
    return new Promise((resolve, reject) => {
        callback(...args, (err, result) => {
            if (err)
                reject(err);
            else {
                resolve(result);
            }
        });
    });
}
exports.Promisify = Promisify;
class TimeoutError extends Error {
    constructor(ms) {
        super(`Operation failed to complete within ${ms}ms`);
        this.ms = ms;
    }
}
exports.TimeoutError = TimeoutError;
function timeout(promise, ms) {
    const timeoutPromise = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
            clearTimeout(id);
            reject(new TimeoutError(ms));
        }, ms);
    });
    return Promise.race([promise, timeoutPromise]);
}
exports.timeout = timeout;
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.delay = delay;
function validateRealmPath(path, userId) {
    if (!path) {
        throw new errors.realm.MissingParameters('path');
    }
    let decodedPath = URI.decode(path);
    if (decodedPath.includes('~')) {
        if (userId) {
            decodedPath = decodedPath.replace('~', userId);
        }
        else {
            throw new errors.realm.InvalidParameters({
                name: 'path',
                reason: `path cannot contain a ~. Please use a full absolute path when trying to find the realmFile.`
            });
        }
    }
    if (!decodedPath.startsWith('/')) {
        decodedPath = '/' + decodedPath;
    }
    if (!virtPath_1.mapVirtToRealmPath("/", decodedPath)) {
        throw new errors.realm.InvalidParameters({
            name: 'path',
            reason: `path is invalid. It should start with a slash, consist of Latin letters (A-Z, a-z), digits (0-9), dot (.), dash (-), and underscore (_). All components should be non-empty and not start with a dot. The path should not end with .realm, .realm.lock or .realm.management.`
        });
    }
    return decodedPath;
}
exports.validateRealmPath = validateRealmPath;
function waitForDownload(realm) {
    return waitForProgress(realm, 'download');
}
exports.waitForDownload = waitForDownload;
function waitForUpload(realm) {
    return waitForProgress(realm, 'upload');
}
exports.waitForUpload = waitForUpload;
function convertHttpError(error) {
    if (error.response && error.response.body) {
        const body = error.response.body;
        if (body.hasOwnProperty('code') && body.hasOwnProperty('status')) {
            if (body.hasOwnProperty('invalid_params')) {
                const params = body.invalid_params;
                delete body.invalid_params;
                body.invalidParams = params;
            }
            return body;
        }
    }
    return error;
}
exports.convertHttpError = convertHttpError;
function waitForProgress(realm, direction) {
    return new Promise((resolve, reject) => {
        realm.syncSession.addProgressNotification(direction, 'forCurrentlyOutstandingWork', (completed, completable) => {
            if (completed === completable) {
                resolve();
            }
        });
    });
}
//# sourceMappingURL=util.js.map